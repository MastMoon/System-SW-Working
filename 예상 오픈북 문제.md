# 예상 오픈북 시험 대비 – 종합 문제집

> 이 문서는 [System-SW-Working GitHub Repository README](https://github.com/MastMoon/System-SW-Working/blob/main/README.md)에 기록하신 모든 내용을 바탕으로, 오픈북 시험에서 출제될 가능성이 높은 문제들을 예상하여 정리한 자료입니다.  
> (문제 수는 매우 많고 상세하므로, 필요에 따라 해당 주제만 선택하여 학습하시기 바랍니다.)

---

## 목차

1. [운영체제 기본 개념](#1-운영체제-기본-개념)  
   1.1 [운영체제의 정의와 역할](#11-운영체제의-정의와-역할)  
   1.2 [운영체제의 종류 및 비교](#12-운영체제의-종류-및-비교)  
   1.3 [커널과 사용자 모드](#13-커널과-사용자-모드)  
2. [프로세스와 스레드](#2-프로세스와-스레드)  
   2.1 [프로세스와 스레드의 차이](#21-프로세스와-스레드의-차이)  
   2.2 [프로세스 스케줄링 알고리즘](#22-프로세스-스케줄링-알고리즘)  
   2.3 [동기화 기법 및 경쟁 조건 해결](#23-동기화-기법-및-경쟁-조건-해결)  
   2.4 [데드락 및 예방/회피 기법](#24-데드락-및-예방회피-기법)  
3. [메모리 관리](#3-메모리-관리)  
   3.1 [가상 메모리와 페이징](#31-가상-메모리와-페이징)  
   3.2 [세그멘테이션 및 페이지 테이블](#32-세그멘테이션-및-페이지-테이블)  
   3.3 [페이지 교체 알고리즘](#33-페이지-교체-알고리즘)  
4. [파일 시스템 및 입출력](#4-파일-시스템-및-입출력)  
   4.1 [파일 시스템의 구성요소](#41-파일-시스템의-구성요소)  
   4.2 [디스크 스케줄링 및 I/O 최적화](#42-디스크-스케줄링-및-io-최적화)  
   4.3 [버퍼링, 캐싱, 스풀링](#43-버퍼링-캐싱-스풀링)  
5. [시스템 소프트웨어와 응용](#5-시스템-소프트웨어와-응용)  
   5.1 [시스템 소프트웨어 vs 응용 소프트웨어](#51-시스템-소프트웨어-vs-응용-소프트웨어)  
   5.2 [인터프리터, 컴파일러, 가상 머신](#52-인터프리터-컴파일러-가상-머신)  
   5.3 [보안 및 자원 관리](#53-보안-및-자원-관리)  
6. [Docker 및 컨테이너 기술](#6-docker-및-컨테이너-기술)  
   6.1 [Docker 기본 개념 및 아키텍처](#61-docker-기본-개념-및-아키텍처)  
   6.2 [Docker 설치 및 이미지/컨테이너 관리](#62-docker-설치-및-이미지컨테이너-관리)  
   6.3 [Dockerfile 작성 및 최적화](#63-dockerfile-작성-및-최적화)  
   6.4 [Docker Compose 및 Docker Desktop](#64-docker-compose-및-docker-desktop)  
7. [시험 응시 전략 및 오픈북 활용법](#7-시험-응시-전략-및-오픈북-활용법)  
   7.1 [자료 정리 및 인덱스 활용](#71-자료-정리-및-인덱스-활용)  
   7.2 [시간 관리 및 문제 분석 전략](#72-시간-관리-및-문제-분석-전략)

---

## 1. 운영체제 기본 개념

### 1.1 운영체제의 정의와 역할
**문제:** 운영체제(OS)의 정의와 주된 기능은 무엇인가?  
**정답 예시:**  
운영체제는 컴퓨터 하드웨어와 소프트웨어 간의 중개자 역할을 하며, 다음의 주요 기능들을 수행한다.  
- **프로세스 관리:** 프로세스 생성, 스케줄링, 종료 등  
- **메모리 관리:** 가상 메모리 제공, 메모리 보호, 할당 및 해제  
- **파일 시스템 관리:** 파일 및 디렉터리 생성, 삭제, 수정, 권한 관리  
- **I/O 시스템 관리:** 입출력 장치 제어 및 드라이버 제공  
- **보안:** 사용자 인증, 권한 부여, 접근 통제  
**해설:**  
운영체제는 시스템 자원의 효율적 분배와 보호를 위해 필수적으로 요구되며, 사용자와 응용 프로그램이 하드웨어를 직접 제어하지 않도록 추상화 계층을 제공한다.

### 1.2 운영체제의 종류 및 비교
**문제:** 일반 목적 OS, 실시간 OS, 분산 OS, 임베디드 OS의 특징을 비교하라.  
**정답 예시:**  
- **일반 목적 OS (Windows, Linux, macOS):**  
  범용성을 가지고 있으며, 다양한 하드웨어와 응용 프로그램을 지원한다.  
- **실시간 OS (VxWorks, QNX):**  
  엄격한 시간 제어와 빠른 응답 시간이 필요하며, 주로 임베디드 및 산업용 시스템에서 사용된다.  
- **분산 OS (Amoeba, Plan 9):**  
  여러 컴퓨터 간 자원 공유 및 통합 관리를 지원하며, 확장성이 뛰어나다.  
- **임베디드 OS (FreeRTOS, Embedded Linux):**  
  제한된 자원 환경에 최적화되어 있으며, 경량화 및 맞춤형 기능을 제공한다.  
**해설:**  
각 OS는 사용 환경과 목적에 따라 설계되었으며, 시스템 요구사항에 맞춘 OS 선택이 매우 중요하다.

### 1.3 커널과 사용자 모드
**문제:** 커널 모드(Kernel Mode)와 사용자 모드(User Mode)의 차이점을 설명하라.  
**정답 예시:**  
- **커널 모드:**  
  시스템 전체를 제어할 수 있는 높은 권한을 가지며, 하드웨어 및 모든 시스템 리소스에 접근 가능하다.  
- **사용자 모드:**  
  응용 프로그램이 실행되는 제한된 권한의 영역으로, 커널 모드에 비해 안전하지만 하드웨어 접근이 제한된다.  
**해설:**  
모드 간 전환에는 비용이 발생하며, 불필요한 전환을 줄이는 것이 시스템 성능 최적화의 핵심이다.

---

## 2. 프로세스와 스레드

### 2.1 프로세스와 스레드의 차이
**문제:** 프로세스와 스레드의 차이점을 기술하라.  
**정답 예시:**  
- **프로세스:**  
  독립된 실행 단위로, 고유한 주소 공간과 자원(메모리, 파일 등)을 보유한다.  
- **스레드:**  
  프로세스 내에서 실행되는 경량 단위로, 동일 주소 공간을 공유하며 빠른 생성 및 전환이 가능하다.  
**해설:**  
프로세스 간 통신(IPC)은 복잡하고 비용이 크지만, 스레드 간 통신은 상대적으로 효율적이나 동기화 문제에 유의해야 한다.

### 2.2 프로세스 스케줄링 알고리즘
**문제:** FCFS, SJF, RR, Priority 스케줄링 알고리즘의 원리와 장단점을 비교하라.  
**정답 예시:**  
- **FCFS (First Come First Served):**  
  도착 순서대로 실행하므로 구현이 간단하지만, 긴 프로세스가 전체 대기 시간을 늘릴 수 있다.  
- **SJF (Shortest Job First):**  
  실행 시간이 짧은 프로세스를 우선 처리하여 평균 대기 시간을 최소화하나, 실행 시간이 예측하기 어려운 경우 문제가 발생할 수 있다.  
- **RR (Round Robin):**  
  각 프로세스에게 균등한 시간 할당(타임 슬라이스)을 통해 공평한 실행을 보장하지만, 타임 슬라이스가 너무 짧으면 문맥 전환 오버헤드가 커진다.  
- **Priority:**  
  우선순위에 따라 처리하므로 중요한 작업을 먼저 처리할 수 있으나, 낮은 우선순위 프로세스가 기아 상태에 빠질 위험이 있다.  
**해설:**  
각 알고리즘은 시스템의 특성과 업무 부하에 따라 선택되어야 하며, 장단점을 종합적으로 고려한 답변이 요구된다.

### 2.3 동기화 기법 및 경쟁 조건 해결
**문제:** 뮤텍스, 세마포어, 모니터, 조건 변수의 차이와 사용 사례를 설명하라.  
**정답 예시:**  
- **뮤텍스:** 단일 임계 구역에 대한 상호 배제를 제공하며, 한 번에 하나의 스레드만 접근할 수 있게 한다.  
- **세마포어:** 정수 카운트를 활용하여 여러 스레드가 동시에 제한된 자원에 접근할 수 있게 제어한다.  
- **모니터:** 객체 지향 방식의 동기화로, 내부적으로 뮤텍스와 조건 변수를 포함하여 관리하며, 메서드 단위로 동기화를 지원한다.  
- **조건 변수:** 특정 조건이 만족될 때까지 스레드를 대기시키고, 조건이 충족되면 신호를 보내어 대기 중인 스레드를 깨운다.  
**해설:**  
각 동기화 기법은 특정 상황에 맞게 사용되며, 경쟁 조건(race condition) 문제 해결에 필수적인 역할을 한다.

### 2.4 데드락 및 예방/회피 기법
**문제:** 데드락의 4가지 발생 조건과 이를 예방하거나 회피하는 방법을 설명하라.  
**정답 예시:**  
데드락의 발생 조건은 다음과 같다.  
1. **상호 배제:** 자원은 한 번에 한 프로세스만 사용할 수 있다.  
2. **점유와 대기:** 한 프로세스가 자원을 점유한 채 다른 자원을 요청한다.  
3. **비선점:** 자원이 강제로 회수될 수 없다.  
4. **순환 대기:** 자원 할당 요청이 순환 구조를 이룬다.  
예방/회피 방법으로는 자원 할당 순서를 미리 정하거나, 은행가 알고리즘을 통해 안전 상태 여부를 확인하는 방식 등이 있다.  
**해설:**  
데드락 해결 방법은 시스템 설계 단계부터 고려되어야 하며, 예방과 회피 기법의 선택은 시스템의 요구사항에 따라 달라진다.

---

## 3. 메모리 관리

### 3.1 가상 메모리와 페이징
**문제:** 가상 메모리의 개념과 페이징 기법의 장단점을 설명하라.  
**정답 예시:**  
가상 메모리는 실제 물리 메모리보다 큰 메모리 공간을 제공하여 프로세스 간 격리와 보호를 가능하게 하는 기법이다.  
**페이징:** 메모리를 고정 크기의 페이지로 분할하여 관리함으로써 외부 단편화를 줄이고, 페이지 교체 기법을 통해 효율적으로 메모리 사용을 최적화한다.  
- **장점:** 외부 단편화 제거, 메모리 관리 단순화  
- **단점:** 페이지 테이블 관리 비용, 내부 단편화 발생 가능  
**해설:**  
페이징과 가상 메모리는 현대 운영체제에서 필수적인 개념이며, 페이지 교체 알고리즘과 함께 이해해야 한다.

### 3.2 세그멘테이션 및 페이지 테이블
**문제:** 세그멘테이션과 페이지 테이블의 차이 및 장단점을 서술하라.  
**정답 예시:**  
- **세그멘테이션:** 프로그램을 논리적 단위(코드, 데이터, 스택 등)로 분할하나, 가변 크기 때문에 내부 단편화가 발생할 수 있다.  
- **페이지 테이블:** 메모리를 고정 크기 페이지 단위로 관리하여 관리가 용이하며 다단계 페이지 테이블 등으로 메모리 사용을 최적화할 수 있다.  
**해설:**  
두 기법은 상호 보완적인 역할을 하며, 현대 시스템에서는 세그먼트-페이지 기법을 혼합하여 사용하기도 한다.

### 3.3 페이지 교체 알고리즘
**문제:** FIFO, LRU, Optimal 페이지 교체 알고리즘의 원리와 성능 비교를 하라.  
**정답 예시:**  
- **FIFO:** 가장 먼저 들어온 페이지를 제거하는 방식으로, 간단하지만 항상 최적의 선택은 아니다.  
- **LRU:** 최근에 사용되지 않은 페이지를 제거하며, 실제 상황에서 성능이 우수하나 구현 비용이 높다.  
- **Optimal:** 미래 참조 정보를 기준으로 최적의 페이지를 선택하는 이상적인 모델이나, 실제 구현은 불가능하다.  
**해설:**  
각 알고리즘은 시스템 환경에 따라 장단점이 있으므로, 평균 페이지 부재율 등의 성능 지표를 통해 평가한다.

---

## 4. 파일 시스템 및 입출력

### 4.1 파일 시스템의 구성요소
**문제:** 파일 시스템의 주요 구성요소(디렉터리, inode, 파일 할당 테이블 등)를 서술하라.  
**정답 예시:**  
파일 시스템은 데이터를 효율적으로 저장하고 관리하는 체계이며, 주요 요소는 다음과 같다.  
- **디렉터리:** 파일들의 조직과 구조를 결정  
- **inode:** 파일의 메타데이터(크기, 권한, 생성/수정 시간 등)를 저장  
- **파일 할당 테이블:** 파일이 저장된 물리 블록의 위치 정보 관리  
**해설:**  
이들 구성요소는 파일 시스템의 성능 및 안정성, 그리고 보안 측면에 큰 영향을 미친다.

### 4.2 디스크 스케줄링 및 I/O 최적화
**문제:** SSTF, SCAN, C-SCAN 등의 디스크 스케줄링 알고리즘의 원리와 차이점을 설명하라.  
**정답 예시:**  
- **SSTF (Shortest Seek Time First):** 현재 헤드에서 가장 가까운 요청을 먼저 처리하여 응답 시간을 단축하지만, 편향성이 발생할 수 있다.  
- **SCAN:** 헤드가 한 방향으로 이동하며 모든 요청을 처리하고 끝에 도달하면 반대로 이동하는 방식으로, 공평성을 제공한다.  
- **C-SCAN:** 한쪽 끝에서만 요청을 처리한 후 초기 위치로 바로 돌아가는 방식으로, 평균 응답 시간을 낮춘다.  
**해설:**  
각 스케줄링 방식은 디스크 I/O 성능 최적화와 관련하여 서로 다른 특징과 trade-off를 가진다.

### 4.3 버퍼링, 캐싱, 스풀링
**문제:** 버퍼링, 캐싱, 스풀링이 I/O 성능 향상에 어떻게 기여하는지 설명하라.  
**정답 예시:**  
- **버퍼링:** 입출력 장치와 시스템 간의 속도 차이를 보완하기 위해 임시 저장 공간(버퍼)을 사용.  
- **캐싱:** 자주 사용되는 데이터를 고속 메모리(캐시)에 저장하여 접근 속도를 개선.  
- **스풀링:** 여러 I/O 요청을 순차적으로 처리할 수 있도록 작업을 큐(스풀)에 저장 후 순차 처리.  
**해설:**  
이 기법들은 I/O 병목현상을 완화하고, 시스템 응답성과 처리율을 크게 향상시킨다.

---

## 5. 시스템 소프트웨어와 응용

### 5.1 시스템 소프트웨어 vs 응용 소프트웨어
**문제:** 시스템 소프트웨어와 응용 소프트웨어 간의 차이와 상호 의존성을 설명하라.  
**정답 예시:**  
시스템 소프트웨어는 하드웨어 제어, 자원 관리, 보안 및 인터페이스 제공을 담당하며, 응용 소프트웨어는 시스템 소프트웨어 위에서 특정 사용자 요구 사항을 해결하는 프로그램들이다. 시스템 소프트웨어가 안정적으로 작동해야 응용 소프트웨어도 올바르게 실행된다.  
**해설:**  
각 계층의 역할 분담과 의존 관계를 이해하면, 시스템 설계 및 문제 해결에 큰 도움이 된다.

### 5.2 인터프리터, 컴파일러, 가상 머신
**문제:** 인터프리터와 컴파일러의 차이, 그리고 가상 머신의 역할을 기술하라.  
**정답 예시:**  
- **컴파일러:** 전체 소스 코드를 기계어로 변환하여 실행 파일을 생성, 실행 속도가 빠르지만 디버깅이 어려울 수 있음.  
- **인터프리터:** 소스 코드를 한 줄씩 해석하면서 실행, 디버깅에 유리하지만 실행 속도가 상대적으로 느림.  
- **가상 머신:** 플랫폼 독립적인 실행 환경을 제공하여 소스 코드의 이식성을 높이며, 예) Java Virtual Machine.  
**해설:**  
각 기술의 특성을 비교하고, 개발 환경에서 장단점이 어떻게 반영되는지 이해해야 한다.

### 5.3 보안 및 자원 관리
**문제:** 시스템 소프트웨어 관점에서 보안과 자원 관리가 왜 중요한지를 사례와 함께 서술하라.  
**정답 예시:**  
보안과 자원 관리는 시스템의 안정성과 신뢰성을 보장하는 근간이다. 예를 들어, 메모리 보호가 없다면 악의적인 코드가 다른 프로세스의 메모리에 접근할 수 있고, 잘못된 자원 분배는 성능 저하와 시스템 충돌을 야기할 수 있다.  
**해설:**  
실제 보안 취약점 사례나 자원 경쟁 문제를 들어 설명하면, 답변의 신뢰도를 높일 수 있다.

---

## 6. Docker 및 컨테이너 기술

### 6.1 Docker 기본 개념 및 아키텍처
**문제:** Docker의 주요 구성요소와 클라이언트-서버 아키텍처를 설명하라.  
**정답 예시:**  
Docker는 컨테이너화 플랫폼으로서,  
- **Docker Client:** 사용자 명령어(예: docker build, docker run)를 입력받아 처리 요청  
- **Docker Daemon (dockerd):** 명령어를 처리하고 컨테이너를 생성, 관리  
- **Docker Registry/Hub:** Docker 이미지를 저장, 배포하는 중앙 저장소  
이러한 구조는 기존의 가상 머신보다 경량화되어 빠른 배포와 높은 자원 효율성을 제공한다.  
**해설:**  
Docker의 기본 철학과 컨테이너 기술이 제공하는 이점을 중심으로 서술한다.

### 6.2 Docker 설치 및 이미지/컨테이너 관리
**문제:** Ubuntu 환경에서 Docker를 설치하고, 이미지를 빌드 및 컨테이너를 실행하는 절차를 설명하라.  
**정답 예시:**  
1. **Docker 설치:**  
   ```bash
   apt-get update
   sudo apt-get install apt-transport-https ca-certificates curl software-properties-common
   curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
   sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"
   sudo apt-get install docker-ce
   ```  
2. **이미지 빌드:**  
   ```bash
   docker build -t my-app:1.0 .
   ```  
3. **컨테이너 실행:**  
   ```bash
   docker run -d -p 80:80 my-app:1.0
   ```  
**해설:**  
설치 시 발생할 수 있는 문제점과 해결 방안을 함께 서술하면 좋다.

### 6.3 Dockerfile 작성 및 최적화
**문제:** Dockerfile의 주요 명령어와 함께, 이미지 빌드 최적화를 위한 베스트 프랙티스를 서술하라.  
**정답 예시:**  
주요 명령어는 `FROM`, `RUN`, `COPY`, `ENV`, `EXPOSE`, `CMD` 등이며,  
- **최적화 방안:**  
  - 불필요한 파일을 제외하기 위해 `.dockerignore` 사용  
  - 가능한 최소한의 베이스 이미지(예: Alpine) 사용  
  - 여러 `RUN` 명령어를 하나로 결합하여 이미지 레이어 수를 최소화  
  - 변하지 않는 파일은 먼저 복사하여 캐시 활용 극대화  
**해설:**  
이미지 크기 감소와 빌드 시간 단축, 보안 개선의 측면에서 최적화 중요성을 강조한다.

### 6.4 Docker Compose 및 Docker Desktop
**문제:** Docker Compose를 활용한 다중 컨테이너 구성 방법과 Docker Desktop의 장단점을 비교하라.  
**정답 예시:**  
- **Docker Compose:**  
  여러 서비스를 하나의 YAML 파일(`docker-compose.yml`)에 정의하고,  
  ```yaml
  version: '3'
  services:
    web:
      image: nginx
      ports:
        - "8080:80"
    db:
      image: mysql:5.7
      environment:
        MYSQL_ROOT_PASSWORD: example
  ```  
  `docker-compose up`으로 모든 서비스를 동시에 실행할 수 있다.  
- **Docker Desktop:**  
  GUI 기반 관리 툴로, 컨테이너, 이미지, 볼륨 등의 상태를 직관적으로 확인할 수 있으나, CLI에 비해 세밀한 제어가 제한될 수 있다.  
**해설:**  
두 도구의 사용 상황과 장단점을 비교 분석하면 답변이 더욱 풍부해진다.

---

## 7. 시험 응시 전략 및 오픈북 활용법

### 7.1 자료 정리 및 인덱스 활용
**문제:** 오픈북 시험 시, 참고 자료를 효과적으로 정리하고 활용하는 방법을 서술하라.  
**정답 예시:**  
- 각 주제별 핵심 개념, 명령어, 예제와 함께 출제 가능성이 높은 부분을 미리 정리하여 목차 및 색인을 작성  
- 페이지 번호나 문서 내 링크를 통해 신속한 검색과 참조가 가능하도록 문서를 구성  
**해설:**  
평소 정리 및 인덱스 작성 습관이 오픈북 시험에서 시간 관리와 문제 해결에 크게 기여한다.

### 7.2 시간 관리 및 문제 분석 전략
**문제:** 오픈북 시험 시 효율적인 시간 관리와 문제 분석을 위한 전략을 서술하라.  
**정답 예시:**  
- 문제를 빠르게 읽고 핵심 키워드를 파악한 후, 정리된 자료에서 해당 정보를 신속히 참조  
- 쉬운 문제부터 먼저 해결하고, 남은 시간에 어려운 문제에 집중하는 전략을 세운다.  
- 모의고사나 기출 문제를 반복적으로 연습하여, 시간 배분과 우선순위 결정을 미리 익힌다.  
**해설:**  
시험 응시 전략은 단순 암기보다는 문제 상황에 맞는 응용 능력을 평가하므로, 자료 정리와 연습이 필수적이다.

---
