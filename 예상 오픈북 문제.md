문제 유형은 개념 설명, 단답형, 서술형, 코드 분석, 빈칸 채우기, 비교 설명 등으로 구성하며, 시험에 자주 출제될 만한 핵심 내용들을 골고루 포함하도록 하겠습니다.


1. [단답형 문제]  
문제: `ls` 명령으로 숨김 파일까지 포함하여 현재 디렉터리의 모든 파일을 표시하려면 어떤 옵션을 사용해야 하나요?  
정답: `ls -a` 옵션을 사용하면 현재 디렉터리의 숨김 파일까지 모두 표시할 수 있습니다.

2. [비교 설명 문제]  
문제: `rm` 명령과 `rmdir` 명령의 차이점을 설명하시오.  
정답: `rm`은 파일을 삭제하는 명령으로, `-r` 옵션을 사용하면 디렉터리와 그 하위 내용을 재귀적으로 삭제할 수 있습니다 (`-f` 옵션으로 확인 없이 강제 삭제 가능). 반면 `rmdir`은 **빈 디렉터리**를 삭제하는 명령으로, 디렉터리가 비어있지 않으면 삭제할 수 없습니다.

3. [단답형 문제]  
문제: 파일의 **처음 5줄**만 출력하고 싶을 때 사용하는 명령어와 옵션은 무엇인가?  
정답: `head -5 <파일명>` 명령을 사용하면 지정한 파일의 처음 5줄만 출력할 수 있습니다.

4. [단답형 문제]  
문제: 주어진 파일이 텍스트 파일인지, 실행 파일인지 등의 **파일 종류**를 확인해주는 리눅스 명령어는 무엇인가?  
정답: `file` 명령어를 사용하면 파일의 유형과 속성을 확인할 수 있습니다. (예: `file example.txt`)

5. [개념 설명 문제]  
문제: 쉘 스크립트의 첫 줄에 사용하는 **Shebang (`#!`)**의 역할은 무엇인가?  
정답: Shebang(`#!`)은 스크립트를 실행할 때 사용할 **쉘 인터프리터를 지정**하는 역할을 합니다. 예를 들어 스크립트의 첫 줄에 `#!/bin/bash`를 넣으면 해당 스크립트가 **Bash 쉘**로 실행됩니다.

6. [개념 설명 문제]  
문제: 리눅스 쉘의 `if` 문은 어떻게 조건을 판단하여 분기하는가?  
정답: `if` 문은 조건으로 주어진 **명령어의 종료 상태(exit status)**를 이용하여 분기합니다. 조건 명령어가 **성공하면(종료 상태 0)** `then` 블록을 실행하고, **실패하면(종료 상태가 0이 아님)** `then` 블록을 건너뜁니다.

7. [개념 설명 문제]  
문제: **`test`** 명령어나 `[ ]` 조건식은 어떤 용도로 사용되는가?  
정답: `test` 명령어(또는 `[ 조건식 ]` 구문)는 주어진 조건식을 평가하여 **참(true)인지 거짓(false)**인지를 판단하는데 사용됩니다. 조건이 참이면 종료 상태 0을 반환하고, 거짓이면 0이 아닌 값을 반환하여 쉘 스크립트의 `if` 문 등에서 조건 분기에 활용됩니다. (`[ ... ]`는 `test`와 동일한 기능을 하는 구문입니다.)

8. [빈칸 채우기 문제]  
문제: 다음 특수 변수들이 의미하는 바를 쓰시오.  
1) 현재 실행 중인 스크립트의 **파일 이름**: ______  
2) **위치 매개변수의 개수**(스크립트에 전달된 인자 개수): ______  
3) 가장 최근에 실행한 명령어의 **종료 상태 코드**: ______  
4) 현재 실행 중인 프로세스의 **PID**(프로세스 ID): ______  
정답:  
1) `$0`  
2) `$#`  
3) `$?`  
4) `$$`  

9. [빈칸 채우기 문제]  
문제: `test` 명령어 또는 `[ ]` 조건식에서, **조건식이 참일 경우** 명령의 종료 상태는 ______이고, **거짓일 경우** 종료 상태는 ______이다.  
정답: 조건이 **참이면 0**, **거짓이면 1**을 반환한다. (일반적으로 쉘에서 종료 상태 0은 성공/참을, 0이 아닌 값은 실패/거짓을 의미합니다.)

10. [빈칸 채우기 문제]  
문제: 다음 비교 연산자 또는 조건식을 채워 넣으시오.  
1) 정수 X가 Y보다 **작으면** 참인 조건식: `X ______ Y`  
2) 정수 X와 Y가 **같지 않으면** 참인 조건식: `X ______ Y`  
3) 문자열 str1과 str2가 **동일하면** 참인 비교 연산자: `str1 ______ str2` (쉘 `[ ]` 문법 기준)  
4) 문자열 str의 길이가 **0이면** 참인 조건식: `______ str`  
정답:  
1) `-lt` (예: `[ "$X" -lt "$Y" ]`)  
2) `-ne` (예: `[ "$X" -ne "$Y" ]`)  
3) `=`  (또는 `==`; 예: `[ "$str1" = "$str2" ]`)  
4) `-z` (예: `[ -z "$str" ]`)

11. [코드 분석 문제]  
문제: 다음은 인자로 전달된 파일의 접근 가능 여부를 검사하는 스크립트 일부이다. `"File $1 is not accessible"` 메시지가 출력되고 스크립트가 종료되는 경우는 어떤 상황인가?  
```bash
if [[ ! -f "$1" || ! -r "$1" || ! -w "$1" ]]; then
    echo "File $1 is not accessible"
    exit 1
fi
```  
정답: 위 조건식은 **인자로 받은 `$1` 파일이** “일반 파일이 아니거나(`-f` 조건 실패) **읽기 가능하지 않거나(`-r` 실패) 쓰기 가능하지 않은 경우**”를 체크합니다. 이 세 조건 중 하나라도 참이면 (즉 파일이 존재하지 않거나, 디렉터리이거나, 존재하지만 읽기/쓰기가 불가능하면) `"File $1 is not accessible"`라는 메시지를 출력하고 `exit 1`로 스크립트를 종료합니다.

12. [단답형 문제]  
문제: **쉘 스크립트의 `if` 조건식**을 작성하는 여러 가지 방법 중 두 가지를 예를 들어 쓰시오.  
정답: 쉘에서 if 조건을 표현하는 방법으로는 `[ ... ]` 형태와 `[[ ... ]]` 형태 두 가지가 있습니다. 예를 들어:  
- `if [ "$VAR" = "Y" ]; then ... fi`  
- `if [[ "$VAR" = "Y" ]]; then ... fi`  
이 두 방법은 기본적으로 동일한 역할을 하며 (`[[ ]]`는 Bash에서 확장된 기능을 제공), 또는 `test "$VAR" = "Y"`를 사용하는 방법도 있습니다.

13. [개념 설명 문제]  
문제: **`case` 문**은 어떤 상황에서 유용하며, 기본 구조는 어떻게 되는지 설명하시오.  
정답: `case` 문은 하나의 변수 값에 대해 **여러 패턴별로 분기**시킬 때 유용하며, 복잡한 다중 `if-elif-else`문을 대체하여 가독성을 높여줍니다. 기본 구조는 다음과 같습니다.  
```bash
case 값 in  
    패턴1) 명령들 ;;  
    패턴2) 명령들 ;;  
    ...  
    *) 명령들 ;;  
esac
```  
주어진 값이 각 패턴과 순서대로 비교되어, 일치하는 패턴의 명령들이 실행됩니다. (`*)`는 어떤 패턴에도 맞지 않을 경우 실행되는 기본 분기입니다.)

14. [비교 설명 문제]  
문제: Bash에서 **`while` 루프**와 **`until` 루프**의 동작 차이를 비교하여 설명하시오.  
정답: `while` 루프는 주어진 **조건식이 참(`true`)인 동안** 반복 실행합니다. 즉, 처음부터 조건이 참이면 루프 본문을 실행하고 조건이 거짓이 되면 종료합니다. 반면 `until` 루프는 **조건식이 거짓(`false`)인 동안** 반복 실행합니다. 즉, 처음에 조건이 거짓이어야 본문을 실행하고, 조건이 참이 되는 순간 루프를 종료합니다. 쉽게 말해 **`while`은 조건이 참인 동안 수행**하고, **`until`은 조건이 참이 될 때까지 수행**하는 차이가 있습니다.

15. [코드 분석 문제]  
문제: 다음 스크립트는 사용자 입력에 따라 반복을 제어합니다. 이 스크립트의 동작을 단계별로 설명하시오.  
```bash
#!/bin/bash
Cont="Y"
while [ "$Cont" = "Y" ]; do
    ps -A
    read -p "Want to continue? (Y/N) " reply
    Cont=$(echo "$reply" | tr '[:lower:]' '[:upper:]')
done
echo "Done"
```  
정답: 이 스크립트는 **현재 실행 중인 모든 프로세스 목록**을 `ps -A`로 출력한 후 사용자가 계속 진행할지 묻습니다. `Cont="Y"`로 초기화해 `while` 루프에 들어가고, 루프 내부에서:  
- 현재 실행 중인 프로세스를 표시합니다.  
- `"Want to continue? (Y/N)"` 프롬프트를 표시하고 사용자의 입력을 `reply` 변수에 받습니다.  
- 입력값을 소문자를 대문자로 변환하여 `Cont` 변수에 저장합니다 (`Y`나 `N` 등 대소문자 구분 없이 처리하기 위해).  
그 후 `while` 조건으로 돌아가 `Cont`가 `"Y"`이면 루프를 계속하고, `"Y"`가 아니면(`N` 등) 루프를 종료합니다. 사용자가 `N`을 입력하여 `Cont`가 `"Y"`가 아니게 되면 루프를 빠져나와 마지막에 `"Done"`을 출력하고 스크립트를 끝냅니다.

16. [코드 분석 문제]  
문제: 다음 스크립트를 실행했을 때 출력되는 결과를 순서대로 쓰시오. (각 `echo` 문에서 무엇이 출력되는지 나열)  
```bash
#!/bin/bash
for index in 1 2 3 4 5 6 7 8 9 10; do
    if [ "$index" -le 3 ]; then
        echo "continue"
        continue
    fi
    echo "$index"
    if [ "$index" -ge 8" ]; then
        echo "break"
        break
    fi
done
```  
정답: 위 스크립트는 `index` 변수가 1부터 10까지 순회합니다. 출력 결과는 조건에 따라 다음과 같이 나타납니다.  
- `index` = 1, 2, 3일 때: if 조건에 의해 `"continue"`만 출력되고, `continue`문으로 아래 `echo`들을 건너뛰어 다음 반복으로 넘어갑니다. 따라서 **세 번 모두 "continue"**가 출력됩니다.  
- `index` = 4, 5, 6, 7일 때: 1~3이 아닌 경우이므로 첫 번째 if를 통과하여 `echo "$index"`가 실행됩니다. 각각 **4, 5, 6, 7**이 출력됩니다. (이때 `index`가 8 미만이어서 두 번째 if의 조건 `-ge 8`은 거짓이므로 `break`는 출력되지 않고 계속 반복)  
- `index` = 8일 때: 첫 번째 if를 통과하여 **`8`**을 출력한 뒤, 두 번째 if 조건 `$index -ge 8`가 참이므로 `"break"`를 출력하고 `break`로 루프를 종료합니다.  
- `index` = 9, 10은 실행되지 않습니다 (이미 루프 종료).  

종합하면 출력 순서는:  
```
continue  
continue  
continue  
4  
5  
6  
7  
8  
break
```

17. [단답형 문제]  
문제: Bash에서 **함수를 정의**하는 기본 구문을 작성하시오. (함수 이름은 `myfunc`로 예시)  
정답: 
```bash
myfunc() {
    명령어들
}
```  
위와 같이 함수이름 뒤에 `()`를 쓰고 중괄호 블록 `{ }` 안에 수행할 명령어들을 넣어서 함수를 정의합니다. 정의한 함수는 나중에 `myfunc` 처럼 이름을 호출하여 실행할 수 있습니다.

18. [개념 설명 문제]  
문제: Bash 함수 내에서 변수를 선언할 때 `local` 키워드를 사용하는 이유는 무엇인가?  
정답: 기본적으로 Bash에서 함수 내에서 선언한 변수는 **전역 변수**로 간주되어 함수 종료 후에도 값이 유지됩니다. `local` 키워드를 붙여 변수를 선언하면 **해당 함수 내부에서만 유효한 지역 변수**가 되어 함수가 끝나면 자동으로 소멸하거나 함수 밖에 영향을 주지 않습니다. 따라서 함수 실행이 외부 환경의 변수에 미치는 영향을 피하기 위해 `local`을 사용합니다.

19. [서술형 문제]  
문제: **가상화(Virtualization)**란 무엇이며, 이를 통해 얻을 수 있는 이점은 무엇인지 설명하시오.  
정답: 가상화는 하나의 물리적 하드웨어 시스템을 여러 개의 **논리적 가상 환경**으로 분할하여 사용하는 기술입니다. 예를 들어 한 대의 서버에서 여러 개의 가상 머신이나 컨테이너를 실행하여 **서로 격리된 환경**을 구축할 수 있습니다. 이를 통해 **하드웨어 자원 활용도를 극대화**하고, 시스템 배치를 유연하게 하며, 물리 장비를 줄여 **비용 절감**과 **관리 효율성 향상**의 이점을 얻을 수 있습니다. 또한 애플리케이션을 서로 격리시켜 **보안성과 안정성**을 높일 수 있다는 장점도 있습니다.

20. [개념 설명 문제]  
문제: 컴퓨터 시스템의 **링 보호(Protection Ring)** 모델에서 **링0**와 **링3**는 무엇이며, 각각 어떤 모드로 동작하는지를 설명하시오.  
정답: 링 보호 모델에서 **링0**는 가장 권한이 높은 **커널 모드(혹은 슈퍼바이저 모드)**를 의미합니다. 운영체제의 핵심 부분이 링0에서 실행되며, 하드웨어 자원에 직접 접근할 수 있습니다. 반면 **링3**는 제한된 권한의 **사용자 모드**로서 일반 응용 프로그램이 실행되는 영역입니다. 사용자 모드에서는 직접 하드웨어에 접근할 수 없으며, 필요한 경우 **시스템 콜**을 통해 링0에 요청을 보내 커널의 기능을 이용합니다. 이렇게 링0과 링3으로 권한을 구분하여 시스템의 **안정성과 보안**을 유지합니다.

21. [단답형 문제]  
문제: **사용자 모드(링3)**에서 **커널 모드(링0)**의 기능을 사용하기 위해 호출해야 하는 것은 무엇인가?  
정답: **시스템 콜(System Call)**을 호출해야 합니다. 시스템 콜은 사용자 모드 프로그램이 커널의 기능을 요청할 때 사용되는 인터페이스로, 이를 통해 링3에서 링0로 모드 전환이 이루어집니다.

22. [개념 설명 문제]  
문제: **하이퍼바이저(Hypervisor)**의 역할은 무엇인가?  
정답: 하이퍼바이저는 물리적인 호스트 머신 위에서 동작하면서 **가상 머신(VM)**들을 생성하고 관리하는 소프트웨어 계층입니다. 하이퍼바이저는 가상 머신들이 **하드웨어 자원을 공유하여 사용할 수 있도록 중재**하며, 각 VM이 서로 **격리된 채로 실행**되도록 합니다. 즉, 하드웨어의 CPU, 메모리, 디스크, 네트워크 자원 등을 가상 머신들에게 적절히 할당하고 스케줄링하여, **여러 운영체제가 한 물리 서버에서 동시에 구동**될 수 있게 해주는 역할을 합니다.

23. [비교 설명 문제]  
문제: **전 가상화(Full Virtualization)**와 **반 가상화(Para-Virtualization)**의 차이를 비교하여 설명하시오.  
정답: **전 가상화**는 Guest 운영체제를 수정하지 않고 그대로 가상 환경에서 실행하는 방식입니다. Guest OS가 **자신이 가상화된 환경인지 모르므로** 하이퍼바이저가 **바이너리 변환(Binary Translation)** 등의 기술을 통해 Guest OS의 특권 명령을 가로채서 처리합니다. 이 방식은 **호환성**이 높아 기존 OS를 그대로 사용할 수 있지만, 변환 작업으로 인해 **성능 저하**가 일부 발생할 수 있습니다.  
**반 가상화**는 Guest OS를 가상화에 맞게 **일부 수정**하여, 운영체제가 가상화된 것을 인지하고 **하이퍼콜(Hypercall)**이라는 인터페이스로 하이퍼바이저와 직접 통신하는 방식입니다. Guest OS가 특권 작업을 할 때 하이퍼콜을 사용하므로 변환 과정이 필요 없어서 **전 가상화보다 성능이 향상**되지만, Guest OS의 **커널 코드를 수정**해야 한다는 단점이 있습니다.

24. [개념 설명 문제]  
문제: Intel VT-x나 AMD-V와 같은 **하드웨어 가상화 지원 기술**이 도입됨으로써 얻은 주요 효과는 무엇인가?  
정답: Intel VT-x, AMD-V 등 CPU의 하드웨어 가상화 지원 기술을 통해 하이퍼바이저는 가상 머신을 더 효율적으로 실행할 수 있게 되었습니다. 구체적으로, 과거 전 가상화에서는 하드웨어 접근을 에뮬레이션해야 해서 오버헤드가 있었지만, **하드웨어 가상화 지원은 Guest OS가 실제 링0에 준하는 환경에서 실행**될 수 있도록 해줌으로써 **가상화 성능을 크게 향상**시켰습니다. 예를 들어, **KVM**과 같은 최신 하이퍼바이저는 이러한 하드웨어 지원을 활용하여 전 가상화 대비 거의 **네이티브에 가까운 속도**를 제공합니다.

25. [비교 설명 문제]  
문제: **Type 1 하이퍼바이저**와 **Type 2 하이퍼바이저**의 차이를 설명하시오.  
정답: **Type 1 하이퍼바이저(베어메탈 하이퍼바이저)**는 **호스트 운영체제 없이** 하드웨어 위에서 직접 동작하는 하이퍼바이저입니다. 물리 서버에 바로 설치되어 동작하므로 **오버헤드가 적고 성능과 안정성이 높으며**, 주로 데이터센터 등에서 쓰입니다. 예시로 VMware ESXi, Microsoft Hyper-V, Xen, KVM 등이 Type 1에 속합니다.  
**Type 2 하이퍼바이저(호스티드 하이퍼바이저)**는 일반 애플리케이션처럼 **호스트 운영체제 위에서 동작**합니다. 즉, 이미 동작중인 OS(예: Windows, Linux)상에서 소프트웨어로 실행되는 가상화 솔루션입니다. 설치와 사용이 비교적 간편하며 주로 **개발/테스트 목적**에 적합하지만, 호스트 OS를 거치므로 Type 1에 비해 **성능 면에서 약간의 오버헤드**가 있습니다. 예시로 Oracle VirtualBox, VMware Workstation/Fusion, Parallels 등이 Type 2에 속합니다.

26. [단답형 문제]  
문제: **Xen 가상화**에서 **Dom0**와 **DomU**는 무엇을 의미하는가?  
정답: **Dom0**는 Xen 하이퍼바이저 환경에서 **특권 도메인(관리 OS)**을 의미합니다. 시스템 부팅 시 가장 먼저 실행되는 VM으로, 하이퍼바이저와 통신하며 **새로운 가상 머신 생성, 자원 할당, I/O 관리 등 전체 가상화 시스템을 제어**하는 역할을 합니다.  
**DomU**는 **일반 도메인(Guest OS)**으로, 사용자가 실행하는 일반 가상 머신들을 가리킵니다. DomU에는 특권이 없으며, 각각 하나의 Guest 운영체제가 실행되어 실제 애플리케이션을 수행하는 가상 환경입니다. (Dom0가 이러한 DomU들을 관리합니다.)

27. [개념 설명 문제]  
문제: **KVM**(Kernel-based Virtual Machine)의 주요 특징을 설명하시오.  
정답: KVM은 리눅스 커널에 하이퍼바이저 기능을 추가한 가상화 기술로, **리눅스 자체를 Type 1 하이퍼바이저로 전환**합니다. KVM 모듈을 커널에 적재하면 각 가상 머신이 **리눅스 프로세스 형태**로 실행되며, Intel VT-x 또는 AMD-V와 같은 **하드웨어 가상화 지원 기술**을 활용하여 높은 성능을 냅니다. 장치 가상화는 QEMU라는 사용자 공간 프로그램을 통해 처리하며, 예를 들어 디스크, 네트워크, USB 등의 I/O를 에뮬레이션합니다. 결과적으로 KVM 환경에서는 각 VM이 `qemu-kvm` 프로세스로 실행되고, 리눅스의 스케줄러에 의해 관리되는 등 리눅스에 자연스럽게 통합되는 구조가 특징입니다.

28. [비교 설명 문제]  
문제: **컨테이너(Container) 가상화**와 전통적인 **가상 머신(VM) 기반 가상화**의 차이를 설명하시오.  
정답: 컨테이너 가상화는 **단일 운영체제 커널** 위에서 격리된 여러 환경을 실행하는 **경량 가상화**입니다. 컨테이너들은 호스트 OS의 커널을 공동으로 사용하면서 프로세스, 파일시스템, 네트워크 등을 **네임스페이스와 cgroups**로 격리하므로, **시작 속도가 빠르고 자원 오버헤드가 적습니다.** 다만 모든 컨테이너는 호스트와 **같은 OS 커널**을 공유하므로 **서로 다른 종류의 OS를 동시에 실행할 수는 없습니다.**  
반면 전통적인 VM 가상화는 하이퍼바이저를 통해 **각 VM마다 자체 OS 커널**을 갖고 실행되는 방식입니다. 각 VM은 완전한 운영체제를 포함하므로 **격리 수준이 높고 다양한 OS를 동시에 운용**가능하지만, 그만큼 **무겁고 부팅 시간이나 자원 소모가 더 큽니다.** 즉, **컨테이너는 경량화된 프로세스 격리**이고 **VM은 완전한 하드웨어 가상화**로 구분됩니다.

29. [개념 설명 문제]  
문제: **Docker**란 무엇이며, 어떤 문제를 해결하기 위해 등장한 기술인가?  
정답: Docker는 애플리케이션을 컨테이너라는 단위로 패키징하여 배포하고 실행할 수 있게 해주는 **오픈소스 컨테이너 플랫폼**입니다. 컨테이너화 기술을 통해 애플리케이션 실행에 필요한 코드, 라이브러리, 설정 등을 하나의 이미지로 묶어 배포함으로써, **환경 차이에 상관없이 어디서나 동일하게 동작**하도록 해줍니다. 이로써 전통적으로 발생하던 “개발 환경에서는 되는데 운영 환경에서는 안 된다”와 같은 **이식성(Portability)** 문제를 해결하며, 가상 머신보다 적은 자원으로 **경량** 실행이 가능하여 효율성을 높입니다.

30. [서술형 문제]  
문제: Docker의 **아키텍처**는 클라이언트-서버 모델로 구성되어 있습니다. Docker 아키텍처의 주요 구성 요소를 설명하시오.  
정답: Docker는 클라이언트-서버 구조로 동작합니다.  
- **Docker Client(클라이언트)**: 사용자가 Docker에게 명령을 내리는 인터페이스입니다. 터미널에서 `docker run`, `docker build` 등의 명령을 입력하면, Docker Client가 해당 명령을 Docker Daemon에 전달합니다.  
- **Docker Daemon(데몬)**: `dockerd`라는 백그라운드 프로세스로 실행되며, 실제로 컨테이너를 관리하고 이미지 빌드 등을 수행하는 핵심 서비스입니다. 클라이언트로부터 명령을 받아 컨테이너를 실행하거나 중지하고, 이미지를 빌드하는 등의 작업을 처리합니다.  
- **Docker Registry(레지스트리)**: Docker 이미지들을 저장하고 배포하는 저장소입니다. Docker Hub 같은 공개 레지스트리가 대표적이며, 사용자는 `docker pull`로 레지스트리에서 이미지를 받아오거나 `docker push`로 이미지를 등록할 수 있습니다.  
이 외에도 Docker 아키텍처의 핵심 개념으로 **이미지(Image)**와 **컨테이너(Container)**가 있습니다. 이미지는 애플리케이션 환경을 캡슐화한 불변의 템플릿이고, 컨테이너는 해당 이미지를 실행한 **실행 중인 인스턴스**입니다. 또한 데이터 저장을 위한 **볼륨(Volume)**, 컨테이너 간 네트워크를 위한 **네트워크(Network)** 구성 요소도 Docker의 아키텍처에서 중요한 부분입니다.

31. [비교 설명 문제]  
문제: **Docker 이미지(Image)**와 **Docker 컨테이너(Container)**의 차이를 설명하시오.  
정답: Docker 이미지는 애플리케이션 실행에 필요한 모든 것(코드, 라이브러리, 환경 설정 등)을 포함한 **읽기 전용 템플릿**입니다. 이미지는 변하지 않는 상태로서 컨테이너를 생성하는 데 사용되며, 하나의 이미지로부터 여러 컨테이너를 만들 수 있습니다.  
Docker 컨테이너는 이 이미지를 기반으로 **실행 중인 인스턴스**를 말합니다. 컨테이너는 이미지의 내용을 복사하여 동작하면서, 추가로 **읽기/쓰기 레이어**를 가져 실행 중 변경되는 데이터나 상태를 관리합니다. 쉽게 말해, **이미지는 프로그램의 청사진**, **컨테이너는 그 청사진으로 실행된 프로세스**라고 볼 수 있습니다.

32. [빈칸 채우기 문제]  
문제: 다음은 Dockerfile의 일부이다. 각 줄에서 사용된 Dockerfile 명령어의 역할을 간략히 쓰시오.  
```dockerfile
FROM ubuntu:22.04  
...  
COPY . .  
...  
EXPOSE 80  
...  
CMD ["nginx", "-g", "daemon off;"]
```  
정답:  
- `FROM`: 기반으로 사용할 **베이스 이미지를 지정**합니다 (위 예에서는 Ubuntu 22.04 이미지를 기반으로 함).  
- `COPY`: 호스트의 파일이나 디렉토리를 이미지 내로 **복사**합니다 (여기서는 현재 디렉터리의 모든 내용 `.`을 이미지의 작업 디렉터리 `.`로 복사).  
- `EXPOSE`: 컨테이너가 실행 중 외부에 **노출할 포트**를 지정합니다 (예에서는 컨테이너의 80번 포트를 개방).  
- `CMD`: 컨테이너가 시작될 때 **기본으로 실행할 명령어**를 지정합니다 (예에서는 Nginx 웹서버를 포어그라운드 모드로 실행).

33. [단답형 문제]  
문제: `docker run` 명령으로 컨테이너를 실행할 때, **백그라운드(detach) 모드**로 실행하고 **호스트의 포트 8080을 컨테이너의 80번 포트**와 연결하려면 어떤 옵션을 사용해야 하는가?  
정답: `-d` 옵션을 사용하면 **백그라운드 실행**(detached mode)이고, `-p 8080:80` 옵션을 사용하면 **포트 매핑**(호스트의 8080 → 컨테이너의 80)입니다. 예를 들어:  
```bash
docker run -d -p 8080:80 <이미지이름>
```  
와 같이 사용합니다.

34. [단답형 문제]  
문제: 현재 **실행 중인 모든 Docker 컨테이너 목록**을 확인하는 명령어는 무엇인가?  
정답: `docker ps` 명령어를 사용하면 현재 동작 중인 모든 컨테이너 목록을 확인할 수 있습니다. (`-a` 옵션을 추가하면 종료된 컨테이너까지 포함한 **전체 컨테이너 목록**을 볼 수 있습니다.)

35. [개념 설명 문제]  
문제: **Docker Compose**는 무엇이며, 어떤 경우에 유용하게 쓰이는지 설명하시오.  
정답: Docker Compose는 여러 개의 컨테이너로 구성된 애플리케이션을 한꺼번에 정의하고 관리하기 위한 **도구**입니다. 보통 `docker-compose.yml`이라는 설정 파일에 웹서버, DB 등 여러 서비스를 하나의 스택으로 정의해두고, `docker-compose up` 명령 한 번으로 **모든 컨테이너를 일괄 실행 및 서로 연동**시킬 수 있습니다. 즉, Compose를 사용하면 복잡한 다중 컨테이너 환경(예: 웹 애플리케이션 + 데이터베이스 + 캐시 서버 등)을 손쉽게 구성하고 시작/중지할 수 있어 **개발 및 배포**에 매우 유용합니다.
